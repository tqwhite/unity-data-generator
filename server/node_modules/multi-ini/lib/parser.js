'use strict'; // match1 - section, match2 - optional full inheritance  part, match3 - inherited section

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var REGEXP_SECTION = /^\s*\[\s*([^:]*?)\s*(:\s*(.+?)\s*)?\]\s*$/;
var REGEXP_COMMENT = /^;.*/;
var REGEXP_SINGLE_LINE = /^\s*(.*?)\s*?=\s*?(\S.*?)$/;
var REGEXP_MULTI_LINE = /^\s*(.*?)\s*?=\s*?"(.*?)$/;
var REGEXP_NOT_ESCAPED_MULTI_LINE_END = /^(.*?)\\"$/;
var REGEXP_MULTI_LINE_END = /^(.*?)"$/;
var REGEXP_ARRAY = /^(.*?)\[\]$/;
var STATUS_OK = 0;
var STATUS_INVALID = 1;
var defaults = {
  ignore_invalid: true,
  keep_quotes: false,
  nested_section_names: false,
  keep_zero_prefix: false,
  oninvalid: function oninvalid() {
    return true;
  },
  filters: [],
  constants: {}
};
var REGEXP_IGNORE_KEYS = /__proto__|constructor|prototype/;

var Parser = /*#__PURE__*/function () {
  function Parser() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, Parser);
    this.options = Object.assign({}, defaults, options);
    this.handlers = [this.handleMultiLineStart, this.handleMultiLineEnd, this.handleMultiLineAppend, this.handleComment, this.handleSection, this.handleSingleLine];
  }

  (0, _createClass2["default"])(Parser, [{
    key: "parse",
    value: function parse(lines) {
      var ctx = {
        ini: {},
        current: {},
        multiLineKeys: false,
        multiLineValue: ''
      };

      var _iterator = _createForOfIteratorHelper(lines),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var line = _step.value;

          var _iterator2 = _createForOfIteratorHelper(this.handlers),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var handler = _step2.value;
              var stop = handler.call(this, ctx, line);

              if (stop) {
                break;
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return ctx.ini;
    }
  }, {
    key: "isSection",
    value: function isSection(line) {
      return line.match(REGEXP_SECTION);
    }
  }, {
    key: "getSection",
    value: function getSection(line) {
      return line.match(REGEXP_SECTION)[1];
    }
  }, {
    key: "getParentSection",
    value: function getParentSection(line) {
      return line.match(REGEXP_SECTION)[3];
    }
  }, {
    key: "isInheritedSection",
    value: function isInheritedSection(line) {
      return !!line.match(REGEXP_SECTION)[3];
    }
  }, {
    key: "isComment",
    value: function isComment(line) {
      return line.match(REGEXP_COMMENT);
    }
  }, {
    key: "isSingleLine",
    value: function isSingleLine(line) {
      var result = line.match(REGEXP_SINGLE_LINE);

      if (!result) {
        return false;
      }

      var check = result[2].match(/"/g);
      return !check || check.length % 2 === 0;
    }
  }, {
    key: "isMultiLine",
    value: function isMultiLine(line) {
      var result = line.match(REGEXP_MULTI_LINE);

      if (!result) {
        return false;
      }

      var check = result[2].match(/"/g);
      return !check || check.length % 2 === 0;
    }
  }, {
    key: "isMultiLineEnd",
    value: function isMultiLineEnd(line) {
      return line.match(REGEXP_MULTI_LINE_END) && !line.match(REGEXP_NOT_ESCAPED_MULTI_LINE_END);
    }
  }, {
    key: "isArray",
    value: function isArray(line) {
      return line.match(REGEXP_ARRAY);
    }
  }, {
    key: "assignValue",
    value: function assignValue(element, keys, value) {
      value = this.applyFilter(value);
      var current = element;
      var previous = element;
      var array = false;
      var key;

      if (keys.some(function (key) {
        return REGEXP_IGNORE_KEYS.test(key);
      })) {
        return;
      }

      var _iterator3 = _createForOfIteratorHelper(keys),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          key = _step3.value;

          if (this.isArray(key)) {
            key = this.getArrayKey(key);
            array = true;
          }

          if (current[key] == null) {
            current[key] = array ? [] : {};
          }

          previous = current;
          current = current[key];
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      if (array) {
        current.push(value);
      } else {
        previous[key] = value;
      }

      return element;
    }
  }, {
    key: "applyFilter",
    value: function applyFilter(value) {
      var _iterator4 = _createForOfIteratorHelper(this.options.filters),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var filter = _step4.value;
          value = filter(value, this.options);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      return value;
    }
  }, {
    key: "getKeyValue",
    value: function getKeyValue(line) {
      var result = line.match(REGEXP_SINGLE_LINE);

      if (!result) {
        throw new Error();
      }

      var _result = (0, _slicedToArray2["default"])(result, 3),
          key = _result[1],
          value = _result[2];

      if (!this.options.keep_quotes) {
        value = value.replace(/^\s*?"(.*?)"\s*?$/, '$1');
      }

      return {
        key: key,
        value: value,
        status: STATUS_OK
      };
    }
  }, {
    key: "getMultiKeyValue",
    value: function getMultiKeyValue(line) {
      var result = line.match(REGEXP_MULTI_LINE);

      if (!result) {
        throw new Error();
      }

      var _result2 = (0, _slicedToArray2["default"])(result, 3),
          key = _result2[1],
          value = _result2[2];

      if (this.options.keep_quotes) {
        value = '"' + value;
      }

      return {
        key: key,
        value: value
      };
    }
  }, {
    key: "getMultiLineEndValue",
    value: function getMultiLineEndValue(line) {
      var result = line.match(REGEXP_MULTI_LINE_END);

      if (!result) {
        throw new Error();
      }

      var _result3 = (0, _slicedToArray2["default"])(result, 2),
          value = _result3[1];

      if (this.options.keep_quotes) {
        value = value + '"';
      }

      return {
        value: value,
        status: STATUS_OK
      };
    }
  }, {
    key: "getArrayKey",
    value: function getArrayKey(line) {
      var result = line.match(REGEXP_ARRAY);
      return result[1];
    }
  }, {
    key: "handleMultiLineStart",
    value: function handleMultiLineStart(ctx, line) {
      if (!this.isMultiLine(line.trim())) {
        return false;
      }

      var _this$getMultiKeyValu = this.getMultiKeyValue(line),
          key = _this$getMultiKeyValu.key,
          value = _this$getMultiKeyValu.value;

      var keys = key.split('.');
      ctx.multiLineKeys = keys;
      ctx.multiLineValue = value;
      return true;
    }
  }, {
    key: "handleMultiLineEnd",
    value: function handleMultiLineEnd(ctx, line) {
      if (!ctx.multiLineKeys || !this.isMultiLineEnd(line.trim())) {
        return false;
      }

      var _this$getMultiLineEnd = this.getMultiLineEndValue(line),
          value = _this$getMultiLineEnd.value,
          status = _this$getMultiLineEnd.status; // abort on false of onerror callback if we meet an invalid line


      if (status === STATUS_INVALID && !this.options.oninvalid(line)) {
        return;
      } // ignore whole multiline on invalid


      if (status === STATUS_INVALID && this.options.ignore_invalid) {
        ctx.multiLineKeys = false;
        ctx.multiLineValue = '';
        return true;
      }

      ctx.multiLineValue += '\n' + value;
      this.assignValue(ctx.current, ctx.multiLineKeys, ctx.multiLineValue);
      ctx.multiLineKeys = false;
      ctx.multiLineValue = '';
      return true;
    }
  }, {
    key: "handleMultiLineAppend",
    value: function handleMultiLineAppend(ctx, line) {
      if (!ctx.multiLineKeys || this.isMultiLineEnd(line.trim())) {
        return false;
      }

      ctx.multiLineValue += '\n' + line;
      return true;
    }
  }, {
    key: "handleComment",
    value: function handleComment(ctx, line) {
      return this.isComment(line.trim());
    }
  }, {
    key: "handleSection",
    value: function handleSection(ctx, line) {
      line = line.trim();

      if (!this.isSection(line)) {
        return false;
      }

      var section = this.getSection(line);

      if (REGEXP_IGNORE_KEYS.test(section)) {
        return false;
      }

      this.createSection(ctx, section);

      if (this.isInheritedSection(line)) {
        var parentSection = this.getParentSection(line);
        ctx.current = Object.assign(ctx.current, JSON.parse(JSON.stringify(ctx.ini[parentSection])));
      }

      return true;
    }
  }, {
    key: "handleSingleLine",
    value: function handleSingleLine(ctx, line) {
      line = line.trim();

      if (!this.isSingleLine(line)) {
        return false;
      }

      var _this$getKeyValue = this.getKeyValue(line),
          key = _this$getKeyValue.key,
          value = _this$getKeyValue.value,
          status = _this$getKeyValue.status; // abort on false of onerror callback if we meet an invalid line


      if (status === STATUS_INVALID && !this.options.oninvalid(line)) {
        throw new Error('Abort');
      } // skip entry


      if (status === STATUS_INVALID && !this.options.ignore_invalid) {
        return true;
      }

      var keys = key.split('.');
      this.assignValue(ctx.current, keys, value);
      return true;
    }
  }, {
    key: "createSection",
    value: function createSection(ctx, section) {
      var sections = (this.options.nested_section_names ? section.split('.') : [section]).map(function (name) {
        return name.trim();
      });
      ctx.current = sections.reduce(function (ini, name) {
        if (typeof ini[name] === 'undefined') {
          ini[name] = {};
        }

        return ini[name];
      }, ctx.ini);
    }
  }]);
  return Parser;
}();

module.exports = Parser;