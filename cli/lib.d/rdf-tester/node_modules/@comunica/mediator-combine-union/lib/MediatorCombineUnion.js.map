{"version":3,"file":"MediatorCombineUnion.js","sourceRoot":"","sources":["MediatorCombineUnion.ts"],"names":[],"mappings":";;;AACA,yCAA0C;AAE1C;;;;GAIG;AACH,MAAa,oBAOX,SAAQ,eAAwB;IAMhC,YAAmB,IAA+C;QAChE,KAAK,CAAC,IAAI,CAAC,CAAC;QACZ,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;IACxC,CAAC;IAEe,KAAK,CAAC,OAAO,CAAC,MAAS;QACrC,IAAI,WAA0C,CAAC;QAC/C,IAAI,CAAC;YACH,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QACrC,CAAC;QAAC,MAAM,CAAC;YACP,WAAW,GAAG,EAAE,CAAC;QACnB,CAAC;QAED,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;YACxB,MAAM,YAAY,GAAkC,EAAE,CAAC;YACvD,KAAK,MAAM,MAAM,IAAI,WAAW,EAAE,CAAC;gBACjC,MAAM,KAAK,GAAG,MAAM,MAAM,CAAC,KAAK,CAAC;gBACjC,IAAI,KAAK,CAAC,QAAQ,EAAE,EAAE,CAAC;oBACrB,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBAC5B,CAAC;YACH,CAAC;YACD,WAAW,GAAG,YAAY,CAAC;QAC7B,CAAC;QAED,yBAAyB;QACzB,MAAM,SAAS,GAAuB,EAAE,CAAC;QACzC,MAAM,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,GAAG,CAAC,KAAK,EAAC,EAAE,KAAK,EAAE,EAAE,CAAC,EAAE,EAAE;YACtD,MAAM,OAAO,GAAG,CAAC,MAAM,KAAK,CAAC,CAAC;YAC9B,MAAM,KAAK,GAAG,OAAO,CAAC,UAAU,EAAE,CAAC;YACnC,SAAS,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,WAAW,EAAE,CAAC;YACrC,OAAO,KAAK,CAAC;QACf,CAAC,CAAC,CAAC,CAAC;QAEJ,4BAA4B;QAC5B,MAAM,OAAO,GAAQ,MAAM,OAAO,CAAC,GAAG,CAAC,WAAW;aAC/C,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC,CAAE,CAAC,CAAC,CAAC,CAAC;QAE1E,+BAA+B;QAC/B,OAAO,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;IAChC,CAAC;IAES,WAAW;QACnB,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;IAC3C,CAAC;IAES,cAAc;QACtB,OAAO,CAAC,OAAY,EAAE,EAAE;YACtB,MAAM,IAAI,GAAQ,EAAE,CAAC;YACrB,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;YACtB,iDAAiD;YACjD,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAW,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;gBAC3D,qDAAqD;iBACpD,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;gBACjB,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,GAAG,KAAK,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;YACvD,CAAC,CAAC,CAAC;YACL,OAAO,IAAI,CAAC;QACd,CAAC,CAAC;IACJ,CAAC;CACF;AAvED,oDAuEC","sourcesContent":["import type { Actor, IAction, IActorOutput, IActorReply, IActorTest, IMediatorArgs, TestResult } from '@comunica/core';\nimport { Mediator } from '@comunica/core';\n\n/**\n * A comunica mediator that takes the union of all actor results.\n *\n * The actors that are registered first will have priority on setting overlapping fields.\n */\nexport class MediatorCombineUnion<\n  A extends Actor<I, T, O, TS>,\nI extends IAction,\nT extends IActorTest,\nO extends IActorOutput,\nTS = undefined,\n>\n  extends Mediator<A, I, T, O, TS>\n  implements IMediatorCombineUnionArgs<A, I, T, O, TS> {\n  public readonly filterFailures: boolean | undefined;\n  public readonly field: string;\n  public readonly combiner: (results: O[]) => O;\n\n  public constructor(args: IMediatorCombineUnionArgs<A, I, T, O, TS>) {\n    super(args);\n    this.combiner = this.createCombiner();\n  }\n\n  public override async mediate(action: I): Promise<O> {\n    let testResults: IActorReply<A, I, T, O, TS>[];\n    try {\n      testResults = this.publish(action);\n    } catch {\n      testResults = [];\n    }\n\n    if (this.filterFailures) {\n      const _testResults: IActorReply<A, I, T, O, TS>[] = [];\n      for (const result of testResults) {\n        const reply = await result.reply;\n        if (reply.isPassed()) {\n          _testResults.push(result);\n        }\n      }\n      testResults = _testResults;\n    }\n\n    // Delegate reply errors.\n    const sideDatas: (TS | undefined)[] = [];\n    await Promise.all(testResults.map(async({ reply }, i) => {\n      const awaited = (await reply);\n      const value = awaited.getOrThrow();\n      sideDatas[i] = awaited.getSideData();\n      return value;\n    }));\n\n    // Run action on all actors.\n    const results: O[] = await Promise.all(testResults\n      .map((result, i) => result.actor.runObservable(action, sideDatas[i]!)));\n\n    // Return the combined results.\n    return this.combiner(results);\n  }\n\n  protected mediateWith(): Promise<TestResult<any, TS>> {\n    throw new Error('Method not supported.');\n  }\n\n  protected createCombiner(): (results: O[]) => O {\n    return (results: O[]) => {\n      const data: any = {};\n      data[this.field] = {};\n      // eslint-disable-next-line unicorn/prefer-spread\n      [{}].concat(results.map((result: any) => result[this.field]))\n        // eslint-disable-next-line unicorn/no-array-for-each\n        .forEach((value) => {\n          data[this.field] = { ...value, ...data[this.field] };\n        });\n      return data;\n    };\n  }\n}\n\nexport interface IMediatorCombineUnionArgs<\n  A extends Actor<I, T, O, TS>,\nI extends IAction,\nT extends IActorTest,\nO extends IActorOutput,\nTS = undefined,\n>\n  extends IMediatorArgs<A, I, T, O, TS> {\n  /**\n   * If actors that throw test errors should be ignored\n   */\n  filterFailures?: boolean;\n  /**\n   * The field name of the test result field over which must be mediated.\n   */\n  field: string;\n}\n"]}