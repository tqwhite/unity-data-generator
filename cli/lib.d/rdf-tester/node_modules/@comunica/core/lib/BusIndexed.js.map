{"version":3,"file":"BusIndexed.js","sourceRoot":"","sources":["BusIndexed.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Actor, IAction, IActorOutput, IActorTest } from './Actor';\nimport type { IActorReply, IBusArgs } from './Bus';\nimport { Bus } from './Bus';\n\n/**\n * A bus that indexes identified actors,\n * so that actions with a corresponding identifier can be published more efficiently.\n *\n * Multiple actors with the same identifier can be subscribed.\n *\n * If actors or actions do not have a valid identifier,\n * then this will fallback to the normal bus behaviour.\n *\n * @see Bus\n *\n * @template A The actor type that can subscribe to the sub.\n * @template I The input type of an actor.\n * @template T The test type of an actor.\n * @template O The output type of an actor.\n */\nexport class BusIndexed<A extends Actor<I, T, O, any>, I extends IAction, T extends IActorTest, O extends IActorOutput>\n  extends Bus<A, I, T, O> {\n  protected readonly actorsIndex: Record<string, A[]> = {};\n  protected readonly actorIdentifierFields: string[];\n  protected readonly actionIdentifierFields: string[];\n\n  /**\n   * All enumerable properties from the `args` object are inherited to this bus.\n   *\n   * @param {IBusIndexedArgs} args Arguments object\n   * @param {string} args.name The name for the bus\n   * @throws When required arguments are missing.\n   */\n  public constructor(args: IBusIndexedArgs) {\n    super(args);\n  }\n\n  public override subscribe(actor: A): void {\n    const actorIds = this.getActorIdentifiers(actor) ?? [ '_undefined_' ];\n    for (const actorId of actorIds) {\n      let actors = this.actorsIndex[actorId];\n      if (!actors) {\n        actors = this.actorsIndex[actorId] = [];\n      }\n      actors.push(actor);\n      super.subscribe(actor);\n    }\n  }\n\n  public override unsubscribe(actor: A): boolean {\n    const actorIds = this.getActorIdentifiers(actor) ?? [ '_undefined_' ];\n    let unsubscribed = false;\n    for (const actorId of actorIds) {\n      const actors = this.actorsIndex[actorId];\n      if (actors) {\n        const i = actors.indexOf(actor);\n        if (i >= 0) {\n          actors.splice(i, 1);\n        }\n        if (actors.length === 0) {\n          delete this.actorsIndex[actorId];\n        }\n      }\n      unsubscribed = unsubscribed || super.unsubscribe(actor);\n    }\n    return unsubscribed;\n  }\n\n  public override publish(action: I): IActorReply<A, I, T, O>[] {\n    const actionId = this.getActionIdentifier(action);\n    if (actionId) {\n      const actors = [ ...this.actorsIndex[actionId] || [], ...this.actorsIndex._undefined_ || [] ];\n      return actors.map((actor: A): IActorReply<A, I, T, O> => ({ actor, reply: actor.test(action) }));\n    }\n    return super.publish(action);\n  }\n\n  protected getActorIdentifiers(actor: A): string[] | undefined {\n    const identifierValue = <string | string[] | undefined> this.actorIdentifierFields\n      .reduce((object: any, field): A => object[field], actor);\n    if (!identifierValue) {\n      return;\n    }\n    return Array.isArray(identifierValue) ? identifierValue : [ identifierValue ];\n  }\n\n  protected getActionIdentifier(action: I): string {\n    return this.actionIdentifierFields.reduce((object: any, field): A => object[field], action);\n  }\n}\n\nexport interface IBusIndexedArgs extends IBusArgs {\n  /**\n   * Keys to follow down from the actor object.\n   * The value at the location following these keys should be a string, a string array, or undefined.\n   * If the value is a string array, all strings will be registered as keys that map to the actor.\n   */\n  actorIdentifierFields: string[];\n  /**\n   * Keys to follow down from the action object.\n   * The value at the location following these keys should be a string or be undefined.\n   */\n  actionIdentifierFields: string[];\n}\n"]}