{"version":3,"file":"TestResult.js","sourceRoot":"","sources":["TestResult.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * A test result represents the result of an actor test that can either be passed or failed.\n *\n * Test results are immutable.\n */\nexport type TestResult<T, TS = undefined> = TestResultPassed<T, TS> | TestResultFailed;\n\n/**\n * Create a new test result that represents a passed value.\n * @param value The value the test passed with.\n */\nexport function passTest<T>(value: T): TestResultPassed<T, undefined> {\n  return new TestResultPassed<T, undefined>(value, undefined);\n}\n\n/**\n * Create a new test result that represents a passed void value.\n */\nexport function passTestVoid(): TestResultPassed<any, undefined> {\n  return new TestResultPassed<any, undefined>(true, undefined);\n}\n\n/**\n * Create a new test result that represents a passed value with side data.\n * @param value The value the test passed with.\n * @param sideData Additional data to pass to the run phase.\n */\nexport function passTestWithSideData<T, S>(value: T, sideData: S): TestResultPassed<T, S> {\n  return new TestResultPassed<T, S>(value, sideData);\n}\n\n/**\n * Create a new test result that represents a passed void value with side data.\n * @param sideData Additional data to pass to the run phase.\n */\nexport function passTestVoidWithSideData<TS>(sideData: TS): TestResultPassed<any, TS> {\n  return new TestResultPassed<any, TS>(true, sideData);\n}\n\n/**\n * Create a new test result that represents a test failure.\n * @param message The error message that describes the failure.\n */\nexport function failTest(message: string): TestResultFailed {\n  return new TestResultFailed(message);\n}\n\n/**\n * A passed test result.\n * This should not be constructed manually.\n * Instead, `testPass` should be used.\n */\nexport class TestResultPassed<T, TS> {\n  protected readonly value: T;\n  protected readonly sideData: TS;\n\n  public constructor(passValue: T, sideData: TS) {\n    this.value = passValue;\n    this.sideData = sideData;\n  }\n\n  /**\n   * Check if the test has passed.\n   * If true, it will contain a value.\n   */\n  public isPassed(): this is TestResultPassed<T, TS> {\n    return true;\n  }\n\n  /**\n   * Check if the test has failed.\n   * If true, it will contain a failure message.\n   */\n  public isFailed(): this is TestResultFailed {\n    return false;\n  }\n\n  /**\n   * Get the value of the passed test, or undefined if the test failed.\n   */\n  public get(): T {\n    return this.value;\n  }\n\n  /**\n   * Get the value of the passed test, or throw an error if the test failed.\n   */\n  public getOrThrow(): T {\n    return this.value;\n  }\n\n  /**\n   * The side data that will be passed to run.\n   */\n  public getSideData(): TS {\n    return this.sideData;\n  }\n\n  /**\n   * Get the failure message callback of the failed test, or undefined if the test passed.\n   */\n  public getFailMessage(): undefined {\n    return undefined;\n  }\n\n  /**\n   * For passed tests, map the passed value to another value.\n   * Failed tests will remain unchanged.\n   *\n   * This will not mutate the test result, and instead return a new test result.\n   *\n   * @param mapper A function that will transform the passed value.\n   */\n  public map<T2>(mapper: (value: T, sideData: TS) => T2): TestResultPassed<T2, TS> {\n    return new TestResultPassed<T2, TS>(mapper(this.value, this.sideData), this.sideData);\n  }\n\n  /**\n   * For passed tests, asynchronously map the passed value to another value.\n   * Failed tests will remain unchanged.\n   *\n   * This will not mutate the test result, and instead return a new test result.\n   *\n   * @param mapper A function that will transform the passed value.\n   */\n  public async mapAsync<T2>(mapper: (value: T, sideData: TS) => Promise<T2>): Promise<TestResultPassed<T2, TS>> {\n    return new TestResultPassed<T2, TS>(await mapper(this.value, this.sideData), this.sideData);\n  }\n}\n\n/**\n * A failed test result.\n * This should not be constructed manually.\n * Instead, `testFail` should be used.\n */\nexport class TestResultFailed {\n  protected readonly failMessage: string;\n\n  public constructor(failMessage: string) {\n    this.failMessage = failMessage;\n  }\n\n  /**\n   * Check if the test has passed.\n   * If true, it will contain a value.\n   */\n  public isPassed(): this is TestResultPassed<any, any> {\n    return false;\n  }\n\n  /**\n   * Check if the test has failed.\n   * If true, it will contain a failure message.\n   */\n  public isFailed(): this is TestResultFailed {\n    return true;\n  }\n\n  /**\n   * Get the value of the passed test, or undefined if the test failed.\n   */\n  public get(): undefined {\n    return undefined;\n  }\n\n  /**\n   * Get the value of the passed test, or throw an error if the test failed.\n   */\n  public getOrThrow(): never {\n    throw new Error(this.getFailMessage());\n  }\n\n  /**\n   * The side data that will be passed to run.\n   */\n  public getSideData(): never {\n    throw new Error(this.getFailMessage());\n  }\n\n  /**\n   * Get the failure message callback of the failed test, or undefined if the test passed.\n   */\n  public getFailMessage(): string {\n    return this.failMessage;\n  }\n\n  /**\n   * For passed tests, map the passed value to another value.\n   * Failed tests will remain unchanged.\n   *\n   * This will not mutate the test result, and instead return a new test result.\n   */\n  public map(): TestResultFailed {\n    return this;\n  }\n\n  /**\n   * For passed tests, asynchronously map the passed value to another value.\n   * Failed tests will remain unchanged.\n   *\n   * This will not mutate the test result, and instead return a new test result.\n   */\n  public async mapAsync(): Promise<TestResultFailed> {\n    return this;\n  }\n}\n"]}