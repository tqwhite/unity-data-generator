{"version":3,"file":"ExpressionEvaluator.js","sourceRoot":"","sources":["ExpressionEvaluator.ts"],"names":[],"mappings":";;;AAkFA,IAAY,cAMX;AAND,WAAY,cAAc;IACxB,yCAAuB,CAAA;IACvB,yCAAuB,CAAA;IACvB,uCAAqB,CAAA;IACrB,+BAAa,CAAA;IACb,uCAAqB,CAAA;AACvB,CAAC,EANW,cAAc,8BAAd,cAAc,QAMzB","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { LRUCache } from 'lru-cache';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport type { ComunicaDataFactory } from './ComunicaDataFactory';\nimport type { IActionContext } from './IActionContext';\n\nexport interface ITimeZoneRepresentation {\n  // https://www.w3.org/TR/xpath-functions/#func-implicit-timezone\n  // Type is a dayTimeDuration.\n  // We use a separate dataType since it makes TS type modifications and JS object copying easier.\n  zoneHours: number;\n  zoneMinutes: number;\n}\n\nexport interface IDateRepresentation extends Partial<ITimeZoneRepresentation> {\n  year: number;\n  month: number;\n  day: number;\n}\n\nexport interface ITimeRepresentation extends Partial<ITimeZoneRepresentation> {\n  hours: number;\n  minutes: number;\n  seconds: number;\n}\n\nexport interface IDayTimeDurationRepresentation {\n  hours: number;\n  minutes: number;\n  seconds: number;\n  day: number;\n}\n\nexport interface IYearMonthDurationRepresentation {\n  year: number;\n  month: number;\n}\n\nexport type IDurationRepresentation = IYearMonthDurationRepresentation & IDayTimeDurationRepresentation;\nexport type IDateTimeRepresentation = IDateRepresentation & ITimeRepresentation;\nexport type AsyncExtensionFunction = (args: RDF.Term[]) => Promise<RDF.Term>;\nexport type AsyncExtensionFunctionCreator = (functionNamedNode: RDF.NamedNode) =>\nPromise<AsyncExtensionFunction | undefined>;\n\n/**\n * The key 'term' is not included in these keys. Something that is just a term will map to number 0.\n */\nexport type GeneralSuperTypeDict = Record<string, number> & { __depth: number };\nexport type TypeCache = LRUCache<string, GeneralSuperTypeDict>;\nexport type SuperTypeCallback = (unknownType: string) => string;\n\nexport interface ISuperTypeProvider {\n  cache: TypeCache;\n  discoverer: SuperTypeCallback;\n}\n\n/**\n * An evaluator for RDF expressions.\n */\nexport interface IExpressionEvaluator extends IInternalEvaluator {\n  /**\n   * Evaluates the provided bindings in terms of the context the evaluator was created.\n   * @param mapping the RDF bindings to evaluate against.\n   */\n  evaluate: (mapping: RDF.Bindings) => Promise<RDF.Term>;\n\n  /**\n   * Evaluates the provided bindings in terms of the context the evaluator was created,\n   * returning the effective boolean value.\n   * @param mapping the RDF bindings to evaluate against.\n   */\n  evaluateAsEBV: (mapping: RDF.Bindings) => Promise<boolean>;\n\n  evaluateAsEvaluatorExpression: (mapping: RDF.Bindings) => Promise<TermExpression>;\n}\n\nexport interface IInternalEvaluator {\n  evaluatorExpressionEvaluation: (expr: Expression, mapping: RDF.Bindings) => Promise<TermExpression>;\n\n  context: IActionContext;\n}\n\nexport enum ExpressionType {\n  Aggregate = 'aggregate',\n  Existence = 'existence',\n  Operator = 'operator',\n  Term = 'term',\n  Variable = 'variable',\n}\nexport type TermType = 'namedNode' | 'literal' | 'blankNode' | 'quad' | 'defaultGraph';\n\nexport type TermExpression = IExpressionProps & {\n  expressionType: ExpressionType.Term;\n  termType: TermType;\n  str: () => string;\n  coerceEBV: () => boolean;\n  toRDF: (dataFactory: ComunicaDataFactory) => RDF.Term;\n};\n\nexport type Expression =\n  AggregateExpression |\n  ExistenceExpression |\n  OperatorExpression |\n  TermExpression |\n  VariableExpression;\n\nexport interface IExpressionProps {\n  expressionType: ExpressionType;\n}\n\nexport type AggregateExpression = IExpressionProps & {\n  expressionType: ExpressionType.Aggregate;\n  name: string;\n  expression: Algebra.AggregateExpression;\n};\n\nexport type ExistenceExpression = IExpressionProps & {\n  expressionType: ExpressionType.Existence;\n  expression: Algebra.ExistenceExpression;\n};\n\nexport type OperatorExpression = IExpressionProps & {\n  expressionType: ExpressionType.Operator;\n  name: string;\n  args: Expression[];\n  apply: FunctionApplication;\n};\n\nexport type VariableExpression = IExpressionProps & {\n  expressionType: ExpressionType.Variable;\n  name: string;\n};\n\nexport type SimpleApplication = (args: TermExpression[]) => TermExpression;\nexport type SimpleApplicationTuple<T> = (args: T) => TermExpression;\n\nexport type FunctionApplication = (evalContext: IEvalContext) => Promise<TermExpression>;\n\nexport type ImplementationFunction = (expressionEvaluator: IInternalEvaluator) => SimpleApplication;\nexport type ImplementationFunctionTuple<T> = (expressionEvaluator: IInternalEvaluator) => SimpleApplicationTuple<T>;\n\nexport interface IFunctionArgumentsCacheObj {\n  func?: ImplementationFunction;\n  cache?: FunctionArgumentsCache;\n}\nexport type FunctionArgumentsCache = Record<string, IFunctionArgumentsCacheObj>;\n\nexport interface IEvalContext {\n  args: Expression[];\n  mapping: RDF.Bindings;\n  exprEval: IInternalEvaluator;\n}\n"]}