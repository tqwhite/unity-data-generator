{"version":3,"file":"MediatorCombinePipeline.js","sourceRoot":"","sources":["MediatorCombinePipeline.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Actor, IAction, IActorOutput, IActorReply, IActorTest, IMediatorArgs, TestResult } from '@comunica/core';\nimport { Mediator } from '@comunica/core';\nimport type { IActionContext } from '@comunica/types';\n\n/**\n * A comunica mediator that goes over all actors in sequence and forwards I/O.\n * This required the action input and the actor output to be of the same type.\n */\nexport class MediatorCombinePipeline<\n  A extends Actor<H, T, H, TS>,\nH extends IAction | (IActorOutput & { context: IActionContext }),\nT extends IActorTest,\nTS = undefined,\n>\n  extends Mediator<A, H, T, H, TS> {\n  public readonly filterFailures: boolean | undefined;\n  public readonly order: 'increasing' | 'decreasing' | undefined;\n  public readonly field: string | undefined;\n\n  public constructor(args: IMediatorCombinePipelineArgs<A, H, T, H, TS>) {\n    super(args);\n  }\n\n  public override async mediate(action: H): Promise<H> {\n    let testResults: IActorReply<A, H, T, H, TS>[] | { actor: A; reply: T }[];\n    try {\n      testResults = this.publish(action);\n    } catch {\n      // If no actors are available, just return the input as output\n      return action;\n    }\n\n    if (this.filterFailures) {\n      const _testResults: IActorReply<A, H, T, H, TS>[] = [];\n      for (const result of testResults) {\n        const reply = await result.reply;\n        if (reply.isPassed()) {\n          _testResults.push(result);\n        }\n      }\n      testResults = _testResults;\n    }\n\n    // Delegate test errors.\n    const sideDatas: (TS | undefined)[] = [];\n    testResults = await Promise.all(testResults\n      .map(async({ actor, reply }, i) => {\n        try {\n          const awaitedReply = await reply;\n          const value = awaitedReply.getOrThrow();\n          sideDatas[i] = awaitedReply.getSideData();\n          return { actor, reply: value };\n        } catch (error: unknown) {\n          throw new Error(this.constructFailureMessage(action, [ (<Error> error).message ]));\n        }\n      }));\n\n    // Order the test results if ordering is enabled\n    if (this.order) {\n      // A function used to extract an ordering value from a test result\n      const getOrder = (elem: T): number => {\n        // If there is a field key use it, otherwise use the input\n        // element for ordering\n        const value = this.field ? (<any> elem)[this.field] : elem;\n\n        // Check the ordering value is a number\n        if (typeof value !== 'number') {\n          throw new TypeError('Cannot order elements that are not numbers.');\n        }\n        return value;\n      };\n\n      testResults = testResults.sort((actor1, actor2) =>\n        (this.order === 'increasing' ? 1 : -1) *\n        (getOrder(actor1.reply) - getOrder(actor2.reply)));\n    }\n\n    // Pass action to first actor,\n    // and each actor output as input to the following actor.\n    let handle: H = action;\n    let i = 0;\n    for (const { actor } of testResults) {\n      handle = { ...handle, ...await actor.runObservable(handle, sideDatas[i++]!) };\n    }\n\n    // Return the final actor output\n    return handle;\n  }\n\n  protected mediateWith(): Promise<TestResult<A, TS>> {\n    throw new Error('Method not supported.');\n  }\n}\n\nexport interface IMediatorCombinePipelineArgs<\n  A extends Actor<I, T, O, TS>,\nI extends IAction,\nT extends IActorTest,\nO extends IActorOutput,\nTS,\n>\n  extends IMediatorArgs<A, I, T, O, TS> {\n  /**\n   * If actors that throw test errors should be ignored\n   */\n  filterFailures?: boolean;\n  /**\n   * The field to use for ordering (if the ordering strategy is chosen).\n   * Leave undefined if the test output is a number rather than an object.\n   */\n  field?: string;\n  /**\n   * The strategy of ordering the pipeline (increasing or decreasing).\n   * For choosing to leave the order of the pipeline unchanged, leave this undefined.\n   * For choosing to order by increasing values: 'increasing'.\n   * For choosing to order by decreasing values: 'decreasing'.\n   */\n  order?: 'increasing' | 'decreasing' | undefined;\n}\n"]}