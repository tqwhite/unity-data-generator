#!/usr/bin/env node
'use strict';
// Suppress punycode deprecation warning
process.noDeprecation = true;

const moduleName = __filename.replace(__dirname + '/', '').replace(/.js$/, ''); //this just seems to come in handy a lot

// const qt = require('qtools-functional-library'); //also exposes qtLog(); qt.help({printOutput:true, queryString:'.*', sendJson:false});

const os = require('os');
const path = require('path');
const fs = require('fs');

// DYNAMIC LIBRARY CREATION GUIDE
// ===============================
// This example demonstrates how to create a dynamic dotD library using qtools-library-dot-d
// 
// KEY CONCEPTS:
// 1. dotD libraries automatically load modules from a specified directory
// 2. All .js files in the dotD directory become available as methods on the library object
// 3. Modules receive shared data through passThroughParameters
// 4. Libraries can be loaded synchronously or asynchronously
// 5. Always call seal() after loading to finalize the library

const qtLibDotD = require('qtools-library-dot-d');


//START OF moduleFunction() ============================================================
const moduleFunction =
	({ moduleName } = {}) =>
	({ unused } = {}) => {
	
		// ========================================================================
		// SYNCHRONOUS DEMO - Use this pattern for simple, immediate library creation

		const synchronousDemo = () => {
			// STEP 1: Create the library instance with a descriptive name
			const demoDotD = qtLibDotD({
				libraryName: 'demoDotD', // This name appears in logs and debugging output
			});

			// STEP 2: Define the path to your dotD modules directory
			// Convention: Use 'ModuleName_DotD' or 'moduleName.d' for the directory name
			const libraryModulesPath = path.join(__dirname, 'demoModules_DotD');

			// STEP 3: Define passThroughParameters - shared data/functions for all modules
			// These parameters are available in every module via the passThroughParameters argument
			// Common uses: configuration, shared utilities, database connections, logging functions
			const passThroughParameters = {
				message: 'Hello from a dotDlib module', // Example: shared message
				add: (a, b) => a + b, // Example: shared utility function
				// Add your own shared resources here:
				// config: getConfig(),
				// logger: xLog,
				// database: dbConnection,
			};

			// STEP 4: Set the library path and load modules
			demoDotD.setLibraryPath(libraryModulesPath);
			demoDotD.loadModules({ passThroughParameters }); // Synchronous loading

			// STEP 5: Seal the library to prevent further modifications
			demoDotD.seal();

			// DEBUGGING: Uncomment to see detailed loading information
			// console.log(demoDotD.qtdProcessLog());
			
			// INSPECTION: See what modules were loaded
			console.log(demoDotD.toString());

			// USAGE: Call your dynamically loaded modules
			// Each .js file in the dotD directory becomes a method with the same name
			demoDotD.demo1(); // Calls demoModules_DotD/demo1.js
			demoDotD.demo2(10, 7); // Calls demoModules_DotD/demo2.js with arguments
		};
			console.log(`SYNCHRONOUS DEMO =====================================`);
			synchronousDemo();
	
		// ========================================================================
		// ASYNCHRONOUS DEMO - Use this pattern when modules need async initialization

		const asynchronousDemo = (callback) => {
			// Create a local callback to handle async completion
			const localCallback = (err) => {
				// IMPORTANT: Always seal after async loading completes
				demoDotD.seal();
				callback(err, demoDotD);
			};

			// STEP 1: Create the library instance
			const demoDotD = qtLibDotD({
				libraryName: 'demoDotD',
			});

			// STEP 2: Define module directory path
			const libraryModulesPath = path.join(__dirname, 'demoModules_DotD');

			// STEP 3: Define shared parameters (same as synchronous version)
			const passThroughParameters = {
				message: 'Hello from a dotDlib module',
				add: (a, b) => a + b,
				// For async loading, you might include:
				// database: await dbConnection(),
				// config: await loadConfig(),
			};

			// STEP 4: Set path and load modules asynchronously
			demoDotD.setLibraryPath(libraryModulesPath);
			demoDotD.loadModules({ passThroughParameters }, localCallback); // Async loading with callback
		};

		console.log(`\n\nASYNCHRONOUS DEMO =====================================`);

		// Define callback to handle async completion
		const callback = (err, demoDotD) => {
			if (err) {
				console.error('Error loading library:', err);
				return;
			}
			// Library is now ready to use
			console.log(demoDotD.toString());
			demoDotD.demo1();
			demoDotD.demo2(10, 7);
		};
		
		// Start async loading
		asynchronousDemo(callback);
	};

//END OF moduleFunction() ============================================================

module.exports = moduleFunction({ moduleName })({});

