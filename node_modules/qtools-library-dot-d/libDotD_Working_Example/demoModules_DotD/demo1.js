#!/usr/bin/env node
'use strict';
// Suppress punycode deprecation warning
process.noDeprecation = true;

const moduleName = __filename.replace(__dirname + '/', '').replace(/.js$/, ''); //this just seems to come in handy a lot

//START OF moduleFunction() ============================================================
// DOTD MODULE STRUCTURE GUIDE
// ============================
// Every dotD module follows this exact pattern:
// 1. Export a function that takes { moduleName } and returns another function
// 2. The returned function receives { dotD, passThroughParameters }
// 3. Define your working function that implements the module's functionality
// 4. Add the working function to the library using dotD.library.add()
// 5. The module name (from filename) becomes the method name on the library

const moduleFunction = ({ moduleName } = {}) => ({ dotD, passThroughParameters } = {}) => {

	// STEP 1: Define your module's main functionality
	// This function will be called when someone uses libraryInstance.demo1()
	const workingFunction = () => {
		// ACCESS SHARED DATA: Use passThroughParameters for shared resources
		console.log(`${passThroughParameters.message} [${moduleName}]`);
		
		// RETURN VALUES: Your function can return any value
		return 'hello';
		
		// COMMON PATTERNS:
		// - Access shared config: passThroughParameters.config
		// - Use shared logger: passThroughParameters.xLog('message')
		// - Access database: passThroughParameters.database.query(...)
		// - Call shared utilities: passThroughParameters.utilityFunction()
	};
	
	// STEP 2: Register the function with the library
	// The moduleName (from filename) becomes the method name
	// Example: demo1.js creates libraryInstance.demo1()
	dotD.library.add(moduleName, workingFunction);
};

//END OF moduleFunction() ============================================================

// STEP 3: Export the configured module function
// This runs immediately when the module is loaded
module.exports = moduleFunction({ moduleName }); //runs it right now